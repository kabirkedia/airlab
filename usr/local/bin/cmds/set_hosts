#!/bin/bash

# Color codes for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly NC='\033[0m' # No Color

# Logging functions
log_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1" >&2; }

show_usage() {
    cat << EOF
Usage: airlab set_hosts <ROBOT_NAME> 

Set hostnames for robots or local environment. Reads from robot.conf file.
When you run this command, it will update the /etc/hosts file on the remote/local machine.
For remote machines it will just sync with 
Arguments:
    ROBOT_NAME    Name of robot (use 'local' for local environment)

Options:
    -h, --help   Show this help message

Examples:
    airlab set_env local     # Set local environment variable
    airlab set_env robot1    # Set remote robot environment
EOF
}
#!/bin/bash


# Function to parse the robot.conf file and return the formatted output
parse_robot_conf() {
    local file="$1"
    local result=""
    
    # Loop through each line in the file
    while IFS='=' read -r key value; do
        # Skip empty lines or lines without '='
        if [[ -z "$key" || -z "$value" ]]; then
            continue
        fi

        # Extract the IP address
        ip_address=$(echo "$value" | cut -d'@' -f2)

        # Append the formatted line to the result
        result+=$(printf "%-15s %-10s #Remote system:%s\n" "$ip_address" "$key" "$key")
        result+="\n"
    done < "$file"
    
    echo -e "$result"
}

# Function to update or add markers and content
update_file() {
  local file_path="$1"
  local start_marker="$2"
  local end_marker="$3"
  local new_content="$4"

  # Check if the file exists
  if [[ ! -f "$file_path" ]]; then
    echo "Error: File '$file_path' does not exist."
    return 1
  fi

  # Check if start and end markers are present
  if grep -q "$start_marker" "$file_path" && grep -q "$end_marker" "$file_path"; then
    # Replace content between markers
    awk -v start_marker="$start_marker" -v end_marker="$end_marker" -v new_content="$new_content" '
      $0 == start_marker {print; in_block = 1; next}
      $0 == end_marker {print new_content; print; in_block = 0; next}
      !in_block
    ' "$file_path" > "${file_path}.tmp" && mv "${file_path}.tmp" "$file_path"
  else
    # Add markers and content to the end of the file
    {
      echo
      echo "$start_marker"
      echo "$new_content"
      echo "$end_marker"
    } >> "$file_path"
  fi

  echo "File updated successfully."
}
source_user_environment() {
    if [ -n "$SUDO_USER" ]; then
        # Get AIRLAB_SYSTEM directly
        AIRLAB_SYSTEM=$(su - "$SUDO_USER" -c 'echo $AIRLAB_SYSTEM')
        AIRLAB_PATH=$(su - "$SUDO_USER" -c 'echo $AIRLAB_PATH')
        HOME=$(su - "$SUDO_USER" -c 'echo $HOME')
        
        export AIRLAB_SYSTEM
        export AIRLAB_PATH
        export HOME
        
        # Debug output
        log_info "Loaded variables:"
        log_info "AIRLAB_SYSTEM=$AIRLAB_SYSTEM"
        log_info "AIRLAB_PATH=$AIRLAB_PATH"
        log_info "HOME=$HOME"
    fi
}

set_local_hosts() {

    NORMAL_USER=$SUDO_USER
    log_info "Normal user: $NORMAL_USER"
    su -c "echo  HERE $HOME $AIRLAB_PATH" $NORMAL_USER
    log_info "Sourcing user's bashrc /home/$SUDO_USER/.bashrc"

    log_warn "$AIRLAB_PATH, $HOME, $AIRLAB_SYSTEM"
    log_info "Setting local hosts file"
    log_warn "This command will update the /etc/hosts file on the local machine."

    # AIRLAB_PATH="/home/dtc/airlab_ws"

    # log_warn "AIRLAB_PATH=$AIRLAB_PATH"    
    ROBOT_CONF="$AIRLAB_PATH/robot/robot.conf"

    # Check if the file exists
    if [[ ! -f "$ROBOT_CONF" ]]; then
        log_error "Error: The file '$ROBOT_CONF' does not exist."
        exit 1
    fi
    output=$(parse_robot_conf "$ROBOT_CONF")
    log_info "Setting local hosts file"
    local_hosts_file="/etc/hosts"
    update_file $local_hosts_file "# Airlab Hosts Start" "# Airlab Hosts End" "$output"
    log_info "Local hosts file updated successfully."
}


main() {
    if [[ "$EUID" -ne 0 ]]; then
        echo "This script must be run as root. Please use sudo."
        exit 1
    fi
    [[ $# -lt 1 ]] && { show_usage; error_exit "No command provided"; }

    local system="$1"
    shift
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h | --help)
                show_usage
                exit 0
                ;;
            *)
                log_error "Invalid option: $1"
                show_usage
                exit 1
                ;;
        esac
        shift
    done


    case "$system" in
        local)
            set_local_hosts 
            ;;
        -h|--help)
            show_usage
            ;;
        *)
            set_remote_hosts "$system"
            ;;
    esac
}

main "$@"

